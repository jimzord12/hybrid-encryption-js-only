Failing Tests Summary
===================

0. For the sake of simplicity, we shall drop the support for ECC algorithm.
We will only use ML-KEM-768 & ML-KEM-1024 for the asymmetric, hkdf-256 and hkdf-512 and AES-GCM-256 and AES-GCM-512.
This means we can remove the cha-cha20-poly1305 algorithm and the ECC key provider.

We will have 2 Presets, normal and high-security. In normal we use:
- ML-KEM-768 for asymmetric encryption
- hkdf-256 for key derivation
- AES-GCM-256 for symmetric encryption

In high-security we use:
- ML-KEM-1024 for asymmetric encryption
- hkdf-512 for key derivation
- AES-GCM-512 for symmetric encryption

1. You need to understand each component and how they interact with each other.
  - Hybrid Encryption: Understand the overall architecture and how different algorithms fit together.
  - Key Management: Learn how keys are generated, stored, and accessed securely.
  - Error Handling: Familiarize yourself with the error types and how to handle them gracefully.

2. Create isolated tests in every class method in isolation. Each method should be tested independently to ensure it behaves as expected.
  - Use mocking frameworks to simulate dependencies and isolate the method under test.
  - Ensure that each test case has at least:
    - One assertion to verify the expected outcome.
    - One test for every possible Error
    - Tests for various possible inputs
    - Tests for edge cases and unexpected scenarios
    - Tests for performance and scalability

3. We need to break key management into smaller, more manageable components. This will involve:
  - Refactoring the KeyManager class to separate concerns (e.g., key generation, storage, retrieval).
  - Creating interfaces for key providers to allow for easier swapping and testing.
