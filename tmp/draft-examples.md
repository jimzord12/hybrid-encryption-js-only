# Post-Quantum Hybrid Encryption Example

This updated TypeScript example uses CRYSTALS-Kyber (ML-KEM-768) for
post-quantum key encapsulation and AES-256-GCM from @noble/ciphers for symmetric
encryption and decryption. Note that the even though the shared secret from
ML-KEM is 32 bytes, we use the HKDF for extra security and protocol compliance.

```ts
// Import the necessary modules from @noble/post-quantum, @noble/ciphers, and @noble/hashes
import { ml_kem768 } from '@noble/post-quantum/ml-kem';
import {
  randomBytes,
  utf8ToBytes,
  bytesToUtf8,
} from '@noble/post-quantum/utils';
import { gcm } from '@noble/ciphers/aes';
import { hkdf } from '@noble/hashes/hkdf';
import { sha256 } from '@noble/hashes/sha2';

// Main function for the round trip (synchronous)
function encryptionDecryptionRoundTrip() {
  // Step 1: Alice generates key pair (optional seed for determinism)
  const aliceSeed = randomBytes(64); // 64 bytes for keygen seed
  const aliceKeys = ml_kem768.keygen(aliceSeed);

  // Step 2: Bob encapsulates a shared secret using Alice's public key
  const { cipherText, sharedSecret: bobShared } = ml_kem768.encapsulate(
    aliceKeys.publicKey,
  );

  // Step 3: Alice decapsulates the ciphertext to get the shared secret
  const aliceShared = ml_kem768.decapsulate(cipherText, aliceKeys.secretKey);

  // Verify shared secrets match (they should be identical)
  if (!arraysEqual(aliceShared, bobShared)) {
    throw new Error('Shared secrets do not match!');
  }
  console.log('Shared secrets match:', bytesToUtf8(aliceShared)); // For demo; don't log in production

  // Step 4: Derive AES-256 key from shared secret using HKDF (SHA-256)
  const salt = new Uint8Array(); // Empty salt (common for KEM; use random if needed)
  const info = utf8ToBytes('aes-encryption-key'); // Context-specific label
  const derivedKeyBob = hkdf(sha256, bobShared, salt, info, 32); // 32 bytes for AES-256
  const derivedKeyAlice = hkdf(sha256, aliceShared, salt, info, 32);

  // Step 5: Use the derived key for symmetric encryption
  const message = utf8ToBytes('Hello, this is a secret message!');
  const nonce = randomBytes(12); // 12-byte nonce for AES-GCM

  // Bob encrypts the message using the derived key
  const aesBob = gcm(derivedKeyBob, nonce);
  const encryptedMessage = aesBob.encrypt(message); // Ciphertext includes the authentication tag

  // Step 6: Alice decrypts the message using the derived key
  const aesAlice = gcm(derivedKeyAlice, nonce);
  const decryptedMessage = aesAlice.decrypt(encryptedMessage);

  // Verify decryption
  console.log('Original message:', bytesToUtf8(message));
  console.log('Decrypted message:', bytesToUtf8(decryptedMessage));

  if (!arraysEqual(message, decryptedMessage)) {
    throw new Error('Decryption failed!');
  }
  console.log('Encryption/decryption round trip successful!');
}

// Helper function to compare Uint8Arrays
function arraysEqual(a: Uint8Array, b: Uint8Array): boolean {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}

// Run the example
encryptionDecryptionRoundTrip();
```

# Uint8Arrays (binary data) into PEM format

To convert raw Uint8Array keys generated by @noble/post-quantum (e.g.,
ML-KEM-768 public and private keys) into PEM format using asn1js, you'll need to
encode the keys into an ASN.1 structure, convert it to DER, and then wrap it in
Base64 with PEM headers. Since ML-KEM (CRYSTALS-Kyber) keys are not part of
standard X.509 structures, we'll use a simple ASN.1 format (e.g., wrapping the
raw bytes in an OCTET STRING) with custom PEM labels, as no standard OID exists
yet for ML-KEM keys. Below is a TypeScript example demonstrating how to convert
ML-KEM-768 public and private keys to PEM format using asn1js and pkijs (a
companion library for easier ASN.1 handling). The example assumes you're using
the raw Uint8Array keys from @noble/post-quantum and includes a complete
encryption/decryption round trip for context, with PEM conversion for both
public and private keys.

```ts
import { fromBase64, toBase64 } from '@noble/hashes/utils';
import { AsnParser, AsnSerializer, OctetString } from 'asn1js';
import { Buffer } from 'buffer';

// Convert raw key (Uint8Array) to PEM format
function encodeKeyToPem(key: Uint8Array, label: string): string {
  // Wrap the raw key in an ASN.1 OCTET STRING
  const octetString = new OctetString({ valueHex: key });
  const der = AsnSerializer.serialize(octetString);

  // Convert DER to Base64 and wrap in PEM format
  const base64 = toBase64(Buffer.from(der));
  const pem = `-----BEGIN ${label}-----\n${base64.match(/.{1,64}/g)?.join('\n')}\n-----END ${label}-----`;
  return pem;
}

// Parse PEM back to raw key (Uint8Array)
function decodePemToKey(pem: string, label: string): Uint8Array {
  // Remove PEM headers and newlines
  const base64 = pem
    .replace(`-----BEGIN ${label}-----`, '')
    .replace(`-----END ${label}-----`, '')
    .replace(/\n/g, '');

  // Decode Base64 to DER
  const der = fromBase64(base64);

  // Parse DER to ASN.1 and extract OCTET STRING
  const asn1 = AsnParser.parse(der, OctetString);
  return new Uint8Array(asn1.valueBlock.valueHexView);
}
```
